\chapter{EXPERIMENTS}
\label{expr}
The experiments conducted to evaluate the functionality and performance of the FFVM emulate network switch behavior using multiple threading architectures.
To drive the FFVM, a high level network application language called Steve 
\cite{steve}, developed in collaboration with a fellow research associate,
provided the hosted applications. Each experiment is comprised of a FFVM 
driver, which creates an instance of a virtual switch, and the compiled network
application. Input for the experiments, network traffic, is generated by an 
external application that transmits the contents of a packet capture (PCAP) 
file. PCAP files contain live network data that has been formatted for usage
by 3rd party libraries, such as libpcap \cite{libpcap}. The retransmission of
the capture file simulates a steady flow of input for each experiment to 
evaluate its performance. The traffic is ``framed'' over TCP sockets to 
emulate raw Ethernet frames that would be received at the lowest network 
protocol layer.

In the following sections, the goals for each experiment are 
explained, as well as the different threading architectures implemented and 
the initial results.

\section{L1 Endpoint - No-op}
\label{expr:slurp}
The baseline test for the FFVM is an endpoint application, where a simple
server is constructed that accepts a single connection and reports the 
receive rate. This test evaluates the maximum rate that data can be provided
to an application. Below is a simplified listing of the driver that creates
an instance of a virtual switch and executes the ``nop'' application.

\begin{lstlisting}
// Build a server socket that will accept network connections.
Ipv4_socket_address addr(Ipv4_address::any(), 5000);
Ipv4_stream_socket server(addr);

// Pre-create all standard ports.
Port_eth_tcp port1(1);

// Configure the dataplanes ports before loading applications.
ff::Dataplane dp = "dp1";
dp.add_port(&port1);
dp.load_application("apps/nop.app");
dp.up();

while (running) {
	poll(server, port1);

	if (server.can_read())
		accept_new_connection(server);
	
	if (port1.can_read()) {
		ff::Buffer buf = ff::buffer_pool::alloc();
		port1.receive(buf);
		
		dp.get_application()->process(buf.context());
		
		if (buf.context().has_output_port())
			buf.context().output_port()->send(buf.context());

		ff::buffer_pool::dealloc(buf.id());
	}
}
\end{lstlisting}


\section{L2 Forwarding - Wire}
\label{expr:wire}
Emulate layer 2 forwarding of ethernet frames over TCP sockets.

\section{Threading Models}
\label{expr:models}
Multiple...

\subsection{Single Threaded}
\label{expr:models-single}
Server, I/O Ports, App in a single thread.

\subsection{Port Threaded}
\label{expr:models-port}
Server, I/O Ports on seperate threads. Application shares execution
with I/O ports.

\subsection{Application Threaded}
\label{expr:models-app}
Server, I/O Ports on a single thread. Application on a seperate thread.

\section{Results}
\label{expr:results}
Tables n stuff.
